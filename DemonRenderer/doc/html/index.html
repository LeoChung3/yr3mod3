<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DemonRenderer: DemonRenderer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DemonRenderer
   </div>
   <div id="projectbrief">Renderer for use across final year modules at DMU</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">DemonRenderer </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__demon_renderer_2_r_e_a_d_m_e"></a> The DemonRenderer is a library containing everything you need to create a window with an OpenGL context and render objects in 3D using OpenGL.</p>
<h1>Usage</h1>
<p>DemonRenderer compiles to a static library. To use the DemonRenderer you will need to inherit from the <a class="el" href="class_application.html" title="Provides an application with a window, OpenGL context, logger (spdlog) and a timer.">Application</a> class in your excutable application. This will setup the window and ImGUI functionality should you wish to make use of it.</p>
<div class="fragment"><div class="line">// main.hpp</div>
<div class="line">#pragma once</div>
<div class="line"> </div>
<div class="line">// Entry point -  extern in DemonRenderer application.hpp</div>
<div class="line">#include &quot;core/entryPoint.hpp&quot;</div>
<div class="line"> </div>
<div class="line">class App : public Application</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">    App(const WindowProperties&amp; winProps);</div>
<div class="line">private:</div>
<div class="line">};</div>
</div><!-- fragment --><p>To begin rendering items in you scene you first need to connect a layer to the application. </p><div class="fragment"><div class="line">// app.cpp</div>
<div class="line">#include &quot;app.hpp&quot;</div>
<div class="line">#include &quot;demo.hpp&quot;</div>
<div class="line"> </div>
<div class="line">App::App(const WindowProperties&amp; winProps) : Application(winProps)</div>
<div class="line">{</div>
<div class="line">    m_layer = std::unique_ptr&lt;Layer&gt;(new DemoLayer(m_window));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Application* startApplication()</div>
<div class="line">{</div>
<div class="line">    WindowProperties props(&quot;Demo&quot;, 800, 600);</div>
<div class="line">    props.isHostingImGui = true;</div>
<div class="line">    props.isResizable = false;</div>
<div class="line">    return new App(props);</div>
<div class="line">}</div>
</div><!-- fragment --><p> This layer has a scene to which actors and lights can be added. We begin be getting the geometry and shader for the thing we wish to render. Usually this is done in the layer's constructor. We will load a shader, a model, a texture and create a <a class="el" href="class_v_a_o.html" title="A Vertex array object. Linke VBOs to an IBO.">VAO</a> (geometry) and a material with these. </p><div class="fragment"><div class="line">ShaderDescription phongShaderDesc;</div>
<div class="line">phongShaderDesc.type = ShaderType::rasterization;</div>
<div class="line">phongShaderDesc.vertexSrcPath = &quot;./assets/shaders/Phong/Vert.glsl&quot;;</div>
<div class="line">phongShaderDesc.fragmentSrcPath = &quot;./assets/shaders/Phong/Frag.glsl&quot;;</div>
<div class="line"> </div>
<div class="line">std::shared_ptr&lt;Shader&gt; phongShader;</div>
<div class="line">phongShader = std::make_shared&lt;Shader&gt;(phongShaderDesc);</div>
<div class="line"> </div>
<div class="line">Model cubeModel(&quot;./assets/models/whitecube/whitecube.obj&quot;);</div>
<div class="line"> </div>
<div class="line">VBOLayout cubeLayout = {</div>
<div class="line">    {GL_FLOAT, 3}, // Position</div>
<div class="line">    {GL_FLOAT, 3}, // Normal</div>
<div class="line">    {GL_FLOAT, 2}  // UV co-ords</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">std::shared_ptr&lt;VAO&gt; cubeVAO;</div>
<div class="line">cubeVAO = std::make_shared&lt;VAO&gt;(cubeModel.m_meshes[0].indices);</div>
<div class="line">cubeVAO-&gt;addVertexBuffer(cubeModel.m_meshes[0].vertices, cubeLayout);</div>
<div class="line"> </div>
<div class="line">std::shared_ptr&lt;Texture&gt; cubeTexture;</div>
<div class="line">cubeTexture = std::make_shared&lt;Texture&gt;(cubeModel.m_meshes[0].texturePaths[aiTextureType_DIFFUSE].string().c_str());</div>
<div class="line"> </div>
<div class="line">std::shared_ptr&lt;Material&gt; cubeMaterial;</div>
<div class="line">cubeMaterial = std::make_shared&lt;Material&gt;(phongShader, &quot;u_model&quot;);</div>
<div class="line">cubeMaterial-&gt;setValue(&quot;u_albedo&quot;, glm::vec3(1.0f));</div>
<div class="line">cubeMaterial-&gt;setValue(&quot;u_albedoMap&quot;, cubeTexture);</div>
</div><!-- fragment --><p> We can now initialise the scene and add an actor for our geometry. </p><div class="fragment"><div class="line">m_scene.reset(new Scene);</div>
<div class="line"> </div>
<div class="line">Actor cube;</div>
<div class="line">cube.geometry = cubeVAO;</div>
<div class="line">cube.material = cubeMaterial;</div>
<div class="line"> </div>
<div class="line">cube.translation = glm::vec3(0.f, -1.f, -6.f);</div>
<div class="line">cube.rotation = glm::quat(glm::vec3(0.0f, 0.4f, 0.0f));</div>
<div class="line">cube.recalc();</div>
<div class="line">m_scene-&gt;m_actors.push_back(cube);</div>
</div><!-- fragment --><p> We are also going to need lights (a single directional light for this scene) and a camera. </p><div class="fragment"><div class="line">DirectionalLight dl;</div>
<div class="line">dl.direction = glm::normalize(glm::vec3(1.f, -2.5f, -2.f));</div>
<div class="line">m_scene-&gt;m_directionalLights.push_back(dl);</div>
<div class="line"> </div>
<div class="line">Actor camera;</div>
<div class="line">m_cameraIdx = m_scene-&gt;m_actors.size();</div>
<div class="line">m_scene-&gt;m_actors.push_back(camera);</div>
</div><!-- fragment --><p> Finally we set up our renderpasses. In this example we have a single renderpass. We also need to set values in our UBOs at this point. </p><div class="fragment"><div class="line">RenderPass mainPass;</div>
<div class="line"> </div>
<div class="line">mainPass.scene = m_scene;</div>
<div class="line">mainPass.parseScene();</div>
<div class="line">mainPass.target = std::make_shared&lt;FBO&gt;(); // Default framebuffer</div>
<div class="line">mainPass.camera.projection = glm::perspective(45.f, m_winRef.getWidthf() / m_winRef.getHeightf(), 0.1f, 100.f);</div>
<div class="line">mainPass.viewPort = { 0, 0, m_winRef.getWidth(), m_winRef.getHeight() };</div>
<div class="line"> </div>
<div class="line">mainPass.camera.updateView(m_scene-&gt;m_actors.at(m_cameraIdx).transform);</div>
<div class="line"> </div>
<div class="line">mainPass.UBOmanager.setCachedValue(&quot;b_camera&quot;, &quot;u_view&quot;, mainPass.camera.view);</div>
<div class="line">mainPass.UBOmanager.setCachedValue(&quot;b_camera&quot;, &quot;u_projection&quot;, mainPass.camera.projection);</div>
<div class="line"> </div>
<div class="line">mainPass.UBOmanager.setCachedValue(&quot;b_lights&quot;, &quot;u_viewPos&quot;, m_scene-&gt;m_actors.at(m_cameraIdx).translation);</div>
<div class="line">mainPass.UBOmanager.setCachedValue(&quot;b_lights&quot;, &quot;dLight.colour&quot;, m_scene-&gt;m_directionalLights.at(0).colour);</div>
<div class="line">mainPass.UBOmanager.setCachedValue(&quot;b_lights&quot;, &quot;dLight.direction&quot;, m_scene-&gt;m_directionalLights.at(0).direction);</div>
<div class="line"> </div>
<div class="line">m_renderer.addRenderPass(mainPass);</div>
</div><!-- fragment --><p> The rendering functioning for this demo is very simple, just call the renderer. </p><div class="fragment"><div class="line">void DemoLayer::onRender() const</div>
<div class="line">{</div>
<div class="line">    m_renderer.render();</div>
<div class="line">}</div>
</div><!-- fragment --><p> Currently, nothing needs to happen on update. </p><div class="fragment"><div class="line">void DemoLayer::onUpdate(float timestep)</div>
<div class="line">{</div>
<div class="line">}</div>
</div><!-- fragment --> <h1>Adding Interactivity with Native Scripts</h1>
<p>To add a native script your class needs to inherit from script. The header of a simple camera controller script is given below. </p><div class="fragment"><div class="line">#pragma once</div>
<div class="line"> </div>
<div class="line">#include &lt;glm/glm.hpp&gt;</div>
<div class="line"> </div>
<div class="line">#include &quot;gameObjects/actor.hpp&quot;</div>
<div class="line">#include &quot;windows/GLFWWindowImpl.hpp&quot;</div>
<div class="line"> </div>
<div class="line">class CameraScript : public Script</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">    CameraScript(Actor&amp; actor, GLFWWindowImpl&amp; win, const glm::vec3&amp; movementSpeed, float turnSpeed) :</div>
<div class="line">        Script(actor),</div>
<div class="line">        m_winRef(win),</div>
<div class="line">        m_movementSpeed(movementSpeed),</div>
<div class="line">        m_turnSpeed(turnSpeed)</div>
<div class="line">    {}</div>
<div class="line">    virtual void onUpdate(float timestep) override;</div>
<div class="line">    virtual void onKeyPress(KeyPressedEvent&amp; e) override {};</div>
<div class="line">    virtual void onKeyRelease(KeyReleasedEvent&amp; e) override {};</div>
<div class="line">private:</div>
<div class="line">    GLFWWindowImpl&amp; m_winRef;</div>
<div class="line">    glm::vec3 m_movementSpeed{ 1.f, 1.f, 1.f };</div>
<div class="line">    float m_turnSpeed{ 0.5f };</div>
<div class="line">};</div>
</div><!-- fragment --><p> The accompanying implementation is listed below: </p><div class="fragment"><div class="line">#include &quot;scripts/include/camera.hpp&quot;</div>
<div class="line"> </div>
<div class="line">void CameraScript::onUpdate(float timestep)</div>
<div class="line">{</div>
<div class="line">    bool recalc = false;</div>
<div class="line"> </div>
<div class="line">    glm::vec3 right = { m_actor.transform[0][0], m_actor.transform[0][1], m_actor.transform[0][2] };</div>
<div class="line">    glm::vec3 forward = { -m_actor.transform[2][0], -m_actor.transform[2][1], -m_actor.transform[2][2] };</div>
<div class="line"> </div>
<div class="line">    if (m_winRef.doIsKeyPressed(GLFW_KEY_W)) { m_actor.translation += forward * m_movementSpeed.z * timestep; recalc = true; }</div>
<div class="line">    if (m_winRef.doIsKeyPressed(GLFW_KEY_A)) { m_actor.translation -= right * m_movementSpeed.x * timestep; recalc = true; }</div>
<div class="line">    if (m_winRef.doIsKeyPressed(GLFW_KEY_S)) { m_actor.translation -= forward* m_movementSpeed.z * timestep; recalc = true; }</div>
<div class="line">    if (m_winRef.doIsKeyPressed(GLFW_KEY_D)) { m_actor.translation += right * m_movementSpeed.x * timestep; recalc = true; }</div>
<div class="line">    if (m_winRef.doIsKeyPressed(GLFW_KEY_UP)) { m_actor.translation.y += m_movementSpeed.y * timestep; recalc = true; }</div>
<div class="line">    if (m_winRef.doIsKeyPressed(GLFW_KEY_DOWN)) { m_actor.translation.y -= m_movementSpeed.y * timestep; recalc = true; }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    if (m_winRef.doIsKeyPressed(GLFW_KEY_LEFT)) {</div>
<div class="line">        glm::vec3 EulerAngles = glm::eulerAngles(m_actor.rotation);</div>
<div class="line">        EulerAngles.y += m_turnSpeed * timestep;</div>
<div class="line">        m_actor.rotation = glm::quat(EulerAngles);</div>
<div class="line">        recalc = true;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    if (m_winRef.doIsKeyPressed(GLFW_KEY_RIGHT)) {</div>
<div class="line">        glm::vec3 EulerAngles = glm::eulerAngles(m_actor.rotation);</div>
<div class="line">        EulerAngles.y -= m_turnSpeed * timestep;</div>
<div class="line">        m_actor.rotation = glm::quat(EulerAngles);</div>
<div class="line">        recalc = true;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    if (recalc) m_actor.recalc();</div>
<div class="line">}</div>
</div><!-- fragment --><p>We now need to add the camera script to the camera actor. <b>Scripts rely on pointers, and therefore the address where actors are located not moving. As such, if you are storing actors in a vector you can only add scripts to actor after the vectors size and been finalised.</b> The code below show a our scsript being added to the camera actor. </p><div class="fragment"><div class="line">m_scene-&gt;m_actors.at(m_cameraIdx).attachScript&lt;CameraScript&gt;(mainPass.scene-&gt;m_actors.at(m_cameraIdx), m_winRef, glm::vec3(1.6f, 0.6f, 2.f), 0.5f);</div>
</div><!-- fragment --><p> We now need to call the script and update the camera position in the <a class="el" href="class_u_b_o.html" title="A Uniform buffer obkect Holds a group of data (uniforms) which can be accessed by mulitple shader pro...">UBO</a> every. The code to do this in onUpdate is given below. Ofcourse, if you are using uniforms rather than UBOs then the values of the uniforms need updating in the relevant materials instead. </p><div class="fragment"><div class="line">void DemoLayer::onUpdate(float timestep)</div>
<div class="line">{</div>
<div class="line">    // Update scripts</div>
<div class="line">    for (auto&amp; actor : m_scene-&gt;m_actors)</div>
<div class="line">    {</div>
<div class="line">        actor.onUpdate(timestep);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // Update camera  and its position in UBO</div>
<div class="line">    auto&amp; camera = m_scene-&gt;m_actors.at(m_cameraIdx);</div>
<div class="line"> </div>
<div class="line">    auto&amp; pass = m_renderer.getRenderPass(0);</div>
<div class="line"> </div>
<div class="line">    pass.camera.updateView(camera.transform);</div>
<div class="line">    pass.UBOmanager.setCachedValue(&quot;b_camera&quot;, &quot;u_view&quot;, pass.camera.view);</div>
<div class="line">    pass.UBOmanager.setCachedValue(&quot;b_camera&quot;, &quot;u_viewPos&quot;, camera.translation);</div>
<div class="line">}</div>
</div><!-- fragment --><p> This concludes the demo code. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"/>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
